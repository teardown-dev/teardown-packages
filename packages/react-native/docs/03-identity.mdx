# Identity & Authentication

Manage user sessions and device identity with the IdentityClient.

## Overview

The IdentityClient handles:
- Device fingerprinting
- User identification and session management
- Anonymous and identified user states
- Automatic session persistence

## Identity States

The SDK uses a discriminated union to represent identity states:

```typescript
type IdentifyState = 
  | { type: "unidentified" }
  | { type: "identifying" }
  | { type: "identified", session: Session, version_info: {...} }
```

### State Transitions

```
unidentified → identifying → identified
     ↑                           ↓
     └───────── reset() ─────────┘
```

## Using the Identity Client

### Access via Hook

```typescript
import { useSession } from '@teardown/react-native';

function MyComponent() {
  const session = useSession();
  
  if (!session) {
    return <LoginScreen />;
  }
  
  return <div>Welcome, {session.persona_id}</div>;
}
```

### Access via Core

```typescript
import { useTeardown } from '@teardown/react-native';

function MyComponent() {
  const { core } = useTeardown();
  
  const handleLogin = async () => {
    const result = await core.identity.identify({
      user_id: 'user-123',
      email: 'user@example.com',
      name: 'John Doe',
    });
  };
}
```

## Identifying Users

### Anonymous Identification

Automatically happens on SDK initialization:

```typescript
// Happens automatically when TeardownProvider mounts
await core.identity.identify();
```

This creates an anonymous session with:
- Unique device ID
- Session ID
- Device information
- Version status

### Identified Users

Identify users with their information:

```typescript
const result = await core.identity.identify({
  user_id: 'user-123',
  email: 'user@example.com',
  name: 'John Doe',
});

if (result.success) {
  console.log('Session:', result.data.session_id);
  console.log('Device:', result.data.device_id);
  console.log('Persona:', result.data.persona_id);
  console.log('Token:', result.data.token);
}
```

### Persona Object

```typescript
type Persona = {
  user_id?: string;
  email?: string;
  name?: string;
}
```

All fields are optional. You can identify with just an email, just a user_id, or any combination.

## Session Management

### Getting Current Session

```typescript
// Via hook (reactive)
const session = useSession();

// Via client (direct)
const session = core.identity.getSessionState();
```

### Session Object

```typescript
type Session = {
  session_id: string;   // Unique session identifier
  device_id: string;    // Unique device identifier
  persona_id: string;   // User/persona identifier
  token: string;        // Authentication token
}
```

### Refreshing Session

Re-identify the current persona to refresh session data:

```typescript
const result = await core.identity.refresh();

if (result.success) {
  console.log('Session refreshed');
}
```

Note: `refresh()` only works if already identified.

## Logging Out

Reset the identity state to anonymous:

```typescript
core.identity.reset();
```

This will:
- Clear persisted session data
- Set state to "unidentified"
- Emit state change event
- Trigger re-identification on next app open

## Listening to State Changes

### Via Hook

```typescript
const session = useSession();

// Automatically re-renders on state changes
useEffect(() => {
  console.log('Session changed:', session);
}, [session]);
```

### Via Event Listener

```typescript
useEffect(() => {
  const unsubscribe = core.identity.onIdentifyStateChange((state) => {
    console.log('State changed:', state.type);
    
    if (state.type === 'identified') {
      console.log('User session:', state.session);
    }
  });
  
  return unsubscribe;
}, []);
```

## Identity State

Get the full identity state (not just session):

```typescript
const state = core.identity.getIdentifyState();

switch (state.type) {
  case 'unidentified':
    // No session yet
    break;
  case 'identifying':
    // Identifying in progress
    break;
  case 'identified':
    // Has session and version info
    console.log(state.session);
    console.log(state.version_info);
    break;
}
```

## Error Handling

All identity operations return `AsyncResult`:

```typescript
const result = await core.identity.identify({
  email: 'invalid-email',
});

if (!result.success) {
  console.error('Identification failed:', result.error);
  // Handle error (show message, retry, etc.)
}
```

Common errors:
- Network errors
- Invalid API credentials
- Validation errors (422)
- Server errors

## Best Practices

### 1. Let Auto-Initialization Happen

```typescript
// ✅ Good - automatic anonymous identification
<TeardownProvider core={teardown}>
  <App />
</TeardownProvider>

// ❌ Bad - don't manually call identify on mount
useEffect(() => {
  core.identity.identify();
}, []);
```

### 2. Identify on Login/Signup

```typescript
const handleLogin = async (email: string, password: string) => {
  // Your auth logic
  const user = await login(email, password);
  
  // Identify with Teardown
  await core.identity.identify({
    user_id: user.id,
    email: user.email,
    name: user.name,
  });
};
```

### 3. Reset on Logout

```typescript
const handleLogout = async () => {
  // Your logout logic
  await logout();
  
  // Reset Teardown identity
  core.identity.reset();
};
```

### 4. Use the Hook for Reactive UI

```typescript
function UserProfile() {
  const session = useSession();
  
  if (!session) {
    return <LoginPrompt />;
  }
  
  return <Profile personaId={session.persona_id} />;
}
```

## Next Steps

- [Force Updates](./04-force-updates.mdx)
- [Device Information](./05-device-info.mdx)
- [API Reference](./07-api-reference.mdx)
